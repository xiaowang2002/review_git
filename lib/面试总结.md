#### 1、项目中遇到过最大的困难（从==day10==开始就有难点了）

==面试只要记住登录和预约下单支付功能==

##### ==**医院挂号系统**==

##### 1-1、接口分析

1，科室数据使用Element-ui el-tree组件渲染展示，需要将医院上传的科室数据封装成两层父子级数据；

2，聚合所有排班数据，按日期分页展示，并统计号源数据展示；

3，根据排班日期获取排班详情数据；

##### 1-2、实现分析

​      虽然是一个页面展示所有内容，但是页面相对复杂，我们分步骤实现

1，先实现左侧科室树形展示；

2，其次排班日期分页展示

3，最后根据排班日期获取排班详情数据

有几个接口对我来说比较困难，就像排班的接口，我给你形容一下他的页面效果，他是这样这样的一个页面，左边是大小科室，右上方是具体某个科室的排班（排班会显示他的具体日期，星期几，还有这天的总的可预约数和总的剩余预约数），右下方是排班下的可预约的医生（包括了医生的详情介绍和可预约数、剩余预约数以及挂号的费用），对于大小科室接口，我们首先获取这个医院的所有的科室，然后通过流的方式配合Collectors.groupingBy(Department::getBigcode)获取到一个map集合，键是大科室的编号，值是属于这个大科室的小科室，然后通过遍历map集合，经过一系列封装，返回一个list的departMentVo类 (三个字段，科室编号，科室名称，下级列表)



然后我还要根据医院编号和科室编号（这里用的是mongodb的Criteria） ，查询排班规则数据（通过mongodb的Aggregation.group（）方法），因为排班是要进行分页的，分页用的mongodb的Aggregation的skip()，limit()的方法，通过分页方法获取我们的ScheduleRuleVo类（里面的一些字段是没有值的），然后包装vo类的星期属性（通过jodaTime包中的datetime类，让原来的Date转换为joda的dateTime，然后datetime调用getDayOfWeek方法进行一个swtich-case就可以获取是星期几了（String））向前端返回即可

![image-20230601114623042](C:\Users\王志生\AppData\Roaming\Typora\typora-user-images\image-20230601114623042.png)



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

登录：

openId：是用户在当前公众号下的唯一标识（‘身份证’），就是说通过这个openId，就能区分在这个公众号下具体是哪个用户。

登录这块可能对于我来说挺难的，有两种登录方式，一个手机登录，一个微信登录，我先说手机登录吧，首先前端传过来一个loginVo对象，我们获取vo对象的手机号，和前端输入的验证码，然后分别对手机号和验证码进行判空，然后再对验证码进行校验，后再判断是否为微信登录（获取loginVo的openId是否为空），然后再将刚才微信登录的用户设置手机号，再到数据库中进行更新，因为微信登录的时候就在数据库中进行了存储，只是没有存储用户的手机号，如果没有openId，表示用户是用手机号登录的，然后在到数据库查是否有手机号为输入手机号的用户，没有的话就表示是注册，直接往数据库进行添加，然后还有判断这个用户的状态是否==被禁用==，然后再通过jwt工具类生成token(id和name)，最后把token和name返回给前端。

jwt=公共部分+私有部分（用户的id和用户的昵称）+签名部分

微信登录又不同于手机登录，我们登录时要先获取那个扫的码，所以我们先需要向前端返回appid，redirectUri，state(为什么要传state参数，因为根据微信开放文档，在请求 code 时我们可以提供一个名为 state 的参数。该参数用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验。)，然后用户点击确认登录后**,**微信服务器会向我们发起回调，此时会有两个参数，一个是code，一个是state，然后对这两个请求进行非空判断，然后拿着code和微信appid和appsecret，利用HttpClientUtil工具类请求微信固定地址 ，得到两个值(access_token,openId,这两个值是一个字符串的形式拼接在一起的，我们可能要通过alibaba的fastJson转换一下)，当然请求微信固定地址也有失败的时候，此时我们会得到两个值errcode，errmsg，我们可以通过日志打印出来，看看错误的具体详情，然后我们用openId在数据库进行查询，判断是否为注册还是登录，如果是注册的话，我们需要获取微信用户的个人信息，跟之前一样，我们还是利用HttpClientUtil工具类，带着access_token和openId请求微信固定地址，得到结果，然后我们通过alibaba的fastJson转换一下)，当然请求微信固定地址也有失败的时候，此时我们会得到两个值errcode，errmsg，我们可以通过日志打印出来，看看错误的具体详情，然后我们根据openid获取用户，判断这一次是登录还是注册，如果没有查到用户信息,就是注册，我们需要调用微信个人信息获取的接口。也是通过httpclientutils（access_token和openid）请求微信固定地址，从被alibaba的fastJson转换后的result中获取我们需要的微信的昵称，然后在创建一个用户，set一下他的昵称，openId、status，然后再到数据库中进行保存，最后我们通过jwt生成token(id,name)向前端返回name,openid,token，（我们判断user是否有手机号，如果手机号为空，返回openid，如果手机号不为空，返回openid值是空字符串，前端判断：如果openid不为空，绑定手机号，如果openid为空，不需要绑定手机号，最后我们重定向到前端页面

-----------------------------------------------------------------------------------------------------------------------------------------------------------

获取排班可预约日期数据：

##### 2-1、接口分析

（1）根据预约周期，展示可预约日期数据，按分页展示

（2）选择日期展示当天可预约列表（该接口后台已经实现过）

##### 2-2、页面展示分析

（1）分页展示可预约日期，根据有号、无号、约满等状态展示不同颜色，以示区分

（2）可预约最后一个日期为即将放号日期，根据放号时间页面展示倒计时

答：因为我们需要分页展示可预约日期，但是每个医院的预约规则是不同的，所以我们需要先获取这家医院的预约规则，预约规则的字段有预约周期，放号时间，停挂时间，退号截止天数，退号时间，预约规则（String）,然后我再配合预约规则对可预约日期进行分页，分页细节这块我想想啊，我开始好像通过jodaTime包下的工具类（date（日期）拼接预约规则的放号时间）获取当天放号的时间（年月日时分），然后再获取预约规则的预约周期，就是就是最长能挂多少天后的号，这里有一个小细节，就是如果当天过了挂号时间（这里也是用的jodaTime的工具方法判断的），则预约周期要从后一天开始算，所以周期就加1，然后获取所有的可预约的日期，最后再通过mp的分页方法进行分页（通过start，end的方式，页面的数据是可预约的日期），然后获取当前页的可预约的日期，然后通过mongodb的方法获取当前页的list的BookingScheduleRuleVo类（剩预约数，状态，可预约数，星期几等，当然里面有一些属性是没有值得），然后创建map，通过流的方式将可预约日期作为键，日期对应的vo类作为值，然后遍历这个map，因为vo对象中还有需要属性没有值（像状态，星期几），继续调用方法给这些属性赋值，最后将这些vo对象取出来放进list中，和别的一些参数（放号时间和停号时间）一起返回给前端

![image-20230601192331156](C:\Users\王志生\AppData\Roaming\Typora\typora-user-images\image-20230601192331156.png)



-----------------------------------------------------------------------------------------------------------------------------------------------------------

预约下单（会将挂号信息（像就诊人信息，挂号日期等等）在前台进行一个显示）：

这个接口其实就是根据排班id，获取预约下单数据

首先，我们根据排班id获取排班，然后再根据排本获取医院以及医院的预约规则，然后再创建订单的vo对象，然后对vo对象的属性进行复制，最后向前端返回



保存订单接口：

首先我会通过获取前端传过来的就诊人id，通过feign调用获取就诊人，然后再通过feign调用预约下单接口获取挂号信息（vo对象，包含了预约开始时间，预约截止时间，当天停止挂号时间），然后判断一下当前时间是否处于预约开始时间和预约截止时间之前，然后从vo对象中获取剩余预约数是否大于0，然后创建订单对象，最后将订单对象加入数据库，然后我们创建一个map,将就诊人信息，以及挂号的详情信息放进map中，最后获取医院的url地址，通过工具方法我们对医院的url地址发送请求（携带map），然后那家医院的接口会取出map中的值转换成订单对象，并对订单进行一个添加在他们医院本地的数据库中，最后我们会获取一个result对象（取号时间，取号地址等等字段），然后我们把这些字段更新进我们刚才添加的订单记录中，然后我们创建一个订单mq的vo对象和短信的vo对象，然后对短信的vo对象（手机号，模板值，退号时间，就诊人姓名等）进行赋值，把短信的vo对象注入进mq的vo对象，然后将mqvo对象发送进队列，然后返回订单Id给前端。最后通过消费者（@RabbitListener）更新该预约日期的剩余预约数并且把mqvo对象的短信vo对象发送进队列，然后通过消费者发送短信，用的阿里云

-----------------------------------------------------------------------------------------------------------------------------------------------------------

保存交易接口（PaymentInfo）：通过获取orderInfo对象的值向数据库中添加PaymentInfo数据（==订单的支付类型，订单的支付状态，以及支付金额和支付订单号==）

根据订单号下单，生成链接（弹出支付二维码）：首先我们根据订单id查询订单信息，然后调用保存交易接口，然后我们new 一个map，参数设置为微信支付固定参数，然后访问微信固定地址，获取结果集，我记得他返回的是一个String类型，我当时好像用了WX的工具类转换为map类型，然后我把结果集的url（支付的二维码）和code取出来了，加上totalFee和orderId放进了一个新的map，存进了redis（id为键，map为值），因为我设置了微信支付二维码2小时过期，可采取2小时未支付取消订单，所以这个接口刚开始的时候我进行了一个判断，如果redis中存在了这个订单的id，直接从redis中取出数据进行返回，最后如果支付成功了，我们就更新订单状态和交易状态（医院那边数据库的订单状态也要进行更改），当然我们也可以取消预约，也就是退款，首先我会判断当前时间是否大于订单的退款时间，如果超过了，就抛出自定义异常，然后我拿着医院id和订单Id，去请求医院的退款接口，然后医院数据库那边会对订单状态进行更改，我们本地数据库也要对订单状态进行更改，然后我们创建ordermqvo对象和短信vo对象，设置短信vo对象的手机号和模板code值等一些值，再设置ordermqvo对象的预约日期值，将短信vo对象设置进ordermqvo对象，最后把ordermqvo发送进队列，最后被监听到更改预约日期的剩余预约数+1，然后把短信vo对象发送进队列中，被短信消费者接受，发送退款短信（这里用的阿里云）

#### 2、项目主要用到的技术有哪些，是怎么用的？

mq：发送当天所有的订单id进消费队列，然后被短信消费者一一消费，发送就医提醒，把订单发送进入mq，排版的剩余预约数减1，把短信vo对象发送进队列，然后被消费，取消预约，预约数加+1

redis：数据字典，手机验证码，存储url,code,totalfree,orderid作为map存进redis因为我设置微信支付二维码而消失，二小时未支付取消订单







索引：https://blog.csdn.net/weixin_53142722/article/details/125104440

sql优化：https://blog.csdn.net/weixin_53601359/article/details/115553449?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168531903316800197075686%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168531903316800197075686&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115553449-null-null.142^v88^koosearch_v1,239^v2^insert_chatgpt&utm_term=sql%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4187





